% vi: ft=plaintex sw=2 sts=2

\chapter{Implementation}

\section{Database.coffee}

Let's have a look at the most important methods of the Database class
implementing the algorithms described by Kung and Robinson.

\begin{minted}{coffeescript}
class Database
  # ...

  addTransaction: (transaction) ->
    _.each(
      transaction.writes,
      (value, key) => @write key, value
    )
    @transactions[transaction.tn = @tn += 1] = transaction
\end{minted}

This method applies the changes described by a transaction (contained in the
dictionary |transaction.writes|) and adds the transaction to the internal
transaction lookup table. The transaction is also assigned a transaction number
|transaction.tn|, that is generated by incrementing the internal transaction
number counter of the database. The return value of this method is the
transaction itself, since the return value of an assignment is the assigned
value.

\begin{minted}{coffeescript}
class Database
  # ...

  validate: (transaction, base) ->
    transaction.valid = _.all base, (t) ->
      _.isEmpty _.intersection(
        _.keys(t.writes), transaction.reads
      )
\end{minted}

This method validates a transaction against a list of other transactions, called
|base|, and checks if the write set of any of the base methods intersects with
the read set of the transaction that is to be verified. This method highlights
the power of the \emph{underscore.js} library discussed earlier. Note that
the |transaction.valid| flag is being set here.

\begin{minted}{coffeescript}
class Database
  # ...

  applyTransaction: (transaction) ->
    baseTransactions =
      @getTransactionRange transaction.startTn + 1, @tn

    if @validate transaction, baseTransactions
      @addTransaction transaction

    transaction
\end{minted}

The method |applyTransaction| validates a single transaction and adds the
transaction to the database if the validation against the relevant transactions
is successful. The last statement of the method is the expression |transaction|
which simply returns the processed transaction.


\begin{minted}{coffeescript}
class Database
  # ...
  reintegrateTransactions: (startTn, transactions) ->
    base = @getTransactionRange startTn + 1, @tn

    _.each transactions, (t) =>
      if @validate(t, base)
        @addTransaction t

    transactions
\end{minted}

This method is used for reintegrating a list of transactions that have been made
by a client that has been offline. It is similar to the method
|applyTransaction|, with the difference that it explicitly requires a startTn
(the last valid transaction number known to the client) that is independent of
the \emph{startTn} value of any of the transactions that are being applied.

This concludes the core of the Kung and Robinson algorithm. What follows is the
outline of the integration into the web service

\pagebreak

\section{Server.coffee}

The following code only contains the necessary methods for applying single
transactions and reintegrating a batch of transactions. This is independent from
providing the html interface and the necessary client code, as well as a
read-only access to the database. A possible bottleneck in this design is the
reintegration of a large number of transactions, which would interfere with read
access and the serving of the client interface. One possible solution would be
using three separate processes for reading data, serving the client files and
applying and reintegrating transactions.

\begin{minted}{coffeescript}
require('zappajs') ->
  # initialize empty database
  database = new Database {}

  @on
    # atomic read of a list of keys
    read: ->
      @ack
        tn: database.tn
        values: _.reduce(
          @data,
          ((o, key) ->
            o[key] = database.read(key) or null; o),
          {})

    applyTransaction: ->
      transaction = @data
      database.applyTransaction transaction
      # reply with transaction status
      # and new transaction number
      @ack(
        valid: transaction.valid
        tn: database.tn
      )

    reintegrateTransactions: ->
      {startTn, transactions} = @data
      transactions = database.reintegrateTransactions(
        startTn, transactions
      )

      # reply with dictionary of transaction statuses
      @ack _.reduce(
        transactions,
        ((obj, t) -> obj[t.tn] = t.valid; obj),
        {}
      )
\end{minted}



\pagebreak

\section{Client.coffee}

The client access to the remote database is provided through the class
|RemoteDatabase|. Both methods |applyTransaction| and |reintegrateTransactions|
accept accept callback functions as the last parameter that will be execute once
the server reply (|@ack|) has arrived. If the transaction is invalid
(|transaction.valid == false|), the client can decide how to proceed.

\begin{minted}{coffeescript}
require('zappajs') ->
  @client '/client.js': ->
    @connect()

    # make function-bound methods available
    # inside other functions
    socket_emit = @emit
    socket_on = @on

    class RemoteDatabase
      # @isolatedTransactions is expected
      # to be of type Backbone.Model
      constructor: (@model, @isolatedTransactions) ->
        @online = true

      disconnect: ->
        @online = false
        # clear the offline transaction buffer
        @isolatedTransactions.reset()

      reconnect: (callback) ->
        @online = true
        socket_emit(
          'reintegrateTransactions',
          startTn: @lastValidTn
          transactions: @isolatedTransactions.map((t) => t.toJSON()),
          -> callback @data
        )

      applyTransaction: (transaction, callback) ->
        if @online
          socket_emit(
            'applyTransaction',
            transaction.toJSON(),
            callback
          )
        else
          @isolatedTransactions.add transaction
          callback()
\end{minted}
